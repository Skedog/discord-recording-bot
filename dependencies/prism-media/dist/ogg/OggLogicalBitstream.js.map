{"version":3,"file":"OggLogicalBitstream.js","sourceRoot":"","sources":["../../src/ogg/OggLogicalBitstream.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-var-requires */\n/* eslint-disable @typescript-eslint/no-require-imports */\nimport { Transform, TransformCallback, TransformOptions } from 'stream';\n\ninterface HeaderTypeFlag {\n\tcontinuedPacket: boolean;\n\tfirstPage: boolean;\n\tlastPage: boolean;\n}\n\n/**\n * Serialises a HeaderTypeFlag\n */\nfunction serialiseHeaderTypeFlag(flags: HeaderTypeFlag): number {\n\treturn (flags.continuedPacket ? 0x01 : 0) + (flags.firstPage ? 0x02 : 0) + (flags.lastPage ? 0x04 : 0);\n}\n\n/**\n * Creates valid Ogg lacing values for a given Buffer.\n *\n * @param buffer The buffer to create lacing values for\n * @returns The lacing values\n */\nfunction createLacingValues(buffer: Buffer): number[] {\n\tconst lacingValues = [];\n\tlet i = buffer.length;\n\twhile (i >= 255) {\n\t\tlacingValues.push(255);\n\t\ti -= 255;\n\t}\n\tlacingValues.push(i);\n\treturn lacingValues;\n}\n\nconst OggS = Buffer.from('OggS');\n\n/**\n * Used to control the size of generated created pages\n */\nexport type PageSizeControl = { maxPackets: number } | { maxSegments: number };\n\n/**\n * Options used to configure an Ogg logical bitstream\n */\nexport interface LogicalBitstreamOptions extends TransformOptions {\n\tcrc: boolean;\n\tpageSizeControl: PageSizeControl;\n}\n\n// Lazy loaded from node-crc\nlet crc: (\n\tbits: number,\n\treflection: boolean,\n\texpL: number,\n\texpH: number,\n\tiniL: number,\n\tiniH: number,\n\tfixL: number,\n\tfixH: number,\n\tdata: Buffer,\n) => Buffer | boolean;\n\n/**\n * Transforms an input stream of data into a logical Ogg bitstream that is compliant with the\n * Ogg framing specification {@link https://www.xiph.org/ogg/doc/framing.html}\n */\nexport abstract class OggLogicalBitstream extends Transform {\n\tprotected packets: Buffer[];\n\tprotected lacingValues: number[];\n\tprotected readonly bitstream = 1;\n\tprotected granulePosition = 0;\n\tprotected pageSequence = 0;\n\tprotected options: LogicalBitstreamOptions;\n\tprotected pageSizeController: (packet: Buffer, lacingValues: number[]) => boolean;\n\n\tpublic constructor(options?: Partial<LogicalBitstreamOptions>) {\n\t\tsuper({ writableObjectMode: true, ...options });\n\t\tthis.options = {\n\t\t\tcrc: true,\n\t\t\tpageSizeControl: { maxSegments: 255 },\n\t\t\t...options,\n\t\t};\n\t\tthis.packets = [];\n\t\tthis.lacingValues = [];\n\n\t\tif (this.options.crc) {\n\t\t\tcrc = require('node-crc').crc;\n\t\t} else {\n\t\t\tthis.calculateCRC = () => 0;\n\t\t}\n\n\t\tif (Reflect.has(this.options.pageSizeControl, 'maxSegments')) {\n\t\t\tconst { maxSegments } = this.options.pageSizeControl as { maxSegments: number };\n\t\t\tthis.pageSizeController = (packet: Buffer, lacingValues: number[]) =>\n\t\t\t\tlacingValues.length + this.lacingValues.length > maxSegments;\n\t\t} else {\n\t\t\tconst { maxPackets } = this.options.pageSizeControl as { maxPackets: number };\n\t\t\tthis.pageSizeController = () => this.packets.length + 1 > maxPackets;\n\t\t}\n\t}\n\n\t/**\n\t * Writes pages containing header data once the stream is created.\n\t *\n\t * @param pages The list of pages that should be written\n\t */\n\tprotected writeHeaderPages(pages: Buffer[][]): void {\n\t\tfor (const page of pages) {\n\t\t\tfor (const packet of page) {\n\t\t\t\tthis.writePacket(packet); // this assumes that writePacket will NOT call writePage\n\t\t\t}\n\t\t\tthis.writePage(false, true);\n\t\t}\n\t}\n\n\tpublic _flush(callback: TransformCallback) {\n\t\tthis.writePage(true);\n\t\tcallback();\n\t}\n\n\tpublic _transform(chunk: Buffer, encoding: BufferEncoding, callback: TransformCallback) {\n\t\tthis.writePacket(chunk);\n\t\tcallback();\n\t}\n\n\t/**\n\t * Calculates a valid CRC32 checksum for an Ogg page\n\t *\n\t * @param buffer The data\n\t * @returns The checksum\n\t */\n\tprotected calculateCRC(buffer: Buffer): number {\n\t\tconst value = crc(32, false, 0x04c11db7, 0, 0, 0, 0, 0, buffer);\n\t\tif (typeof value === 'boolean') {\n\t\t\tthrow new Error('Failed to compute CRC for buffer');\n\t\t}\n\t\treturn value.readUInt32BE(0);\n\t}\n\n\t/**\n\t * Calculates the granule position of a page in the logical bitstream given the new packets of the page.\n\t *\n\t * @param packets The packets in the new page\n\t */\n\tprotected abstract calculateGranulePosition(packets: Buffer[]): number;\n\n\t/**\n\t * Attempts to buffer a data packet. If there is already too much data buffered, the existing data is first\n\t * flushed by collecting it into a page and pushing it.\n\t *\n\t * @param packet The data packet to write\n\t */\n\tprotected writePacket(packet: Buffer) {\n\t\tconst lacingValues = createLacingValues(packet);\n\t\tif (lacingValues.length > 255) {\n\t\t\tthrow new Error('OggLogicalBitstream does not support continued pages');\n\t\t}\n\t\tif (this.pageSizeController(packet, lacingValues) || lacingValues.length + this.lacingValues.length > 255) {\n\t\t\tthis.writePage();\n\t\t}\n\t\tthis.packets.push(packet);\n\t\tthis.lacingValues.push(...lacingValues);\n\t}\n\n\t/**\n\t * Collects the buffered data packets into an Ogg page.\n\t *\n\t * @param final Whether this is the final page to be written\n\t * @param logicalHeader Whether this page contains only a header for a logical stream, to avoid\n\t * incrementing the granule position.\n\t */\n\tprotected writePage(final = false, logicalHeader = false) {\n\t\tconst header = Buffer.allocUnsafe(27);\n\t\tif (!logicalHeader) {\n\t\t\tthis.granulePosition = this.calculateGranulePosition(this.packets);\n\t\t}\n\t\t// capture_pattern\n\t\tOggS.copy(header, 0, 0);\n\n\t\t// stream_structure_version\n\t\theader.writeUInt8(0, 4);\n\n\t\t// header_type_flag\n\t\theader.writeUInt8(\n\t\t\tserialiseHeaderTypeFlag({\n\t\t\t\tcontinuedPacket: false,\n\t\t\t\tfirstPage: this.pageSequence === 0,\n\t\t\t\tlastPage: final,\n\t\t\t}),\n\t\t\t5,\n\t\t);\n\n\t\t// absolute granule position\n\t\theader.writeUInt32LE(this.granulePosition, 6);\n\t\theader.writeUInt32LE(0, 10);\n\n\t\t// stream serial number\n\t\theader.writeUInt32LE(this.bitstream, 14);\n\n\t\t// page sequence no\n\t\theader.writeUInt32LE(this.pageSequence++, 18);\n\n\t\t// page checksum - initially 0\n\t\theader.writeUInt32LE(0, 22);\n\n\t\t// page_segments\n\t\theader.writeUInt8(this.lacingValues.length, 26);\n\n\t\tconst page = Buffer.concat([header, Buffer.from(this.lacingValues), ...this.packets]);\n\n\t\t// page checksum - calculate CRC checksum\n\t\tpage.writeUInt32LE(this.calculateCRC(page), 22);\n\n\t\t// reset the buffered packets and their associated lacingValues\n\t\tthis.packets = [];\n\t\tthis.lacingValues = [];\n\n\t\tthis.push(page);\n\t}\n}\n"]}